import React, {Component} from 'react';

export default class Practice extends Component{

    componentDidMount(){
      
      /**
       * JavaScript没有严格意义上的类，因此只能通过构造器检测实例
       * instanceof 也会检测类的继承关系，对祖先类运算也会是true
       * 
       * 语句是有值的
       * alert( eval('a = (1,2,3);') );  //a=3
       * alert( eval('a = 1,2,3;') );    //a=1
       * 上面两个表达式结果都是3
       * 不同于var a = 1,2,3; 报错，因为var声明会使连续运算表达式变成连续声明语句
       * 
       * 函数的原型总是一个标准的、系统内置的Object()构造器实例，该实例constructor属性被
       * 赋值为当前函数。
       * 
       * 原型的含义是如果一个构造器有原型对象A，则由该构造器创建的的实例都复制自A，
       * 创建空对象就是Object.prototype，
       * 写时复制，读的时候就是读Object.prototype，写的时候才会去复制一个出来；
       * 或者仅当写某个实例的成员时，将成员的信息复制到实例映像中。
       * 
       * 构造器的prototype属性总是来自于new Object() 产生的实例。
       * JavaScript对象实质是一个指向其原型并持有一个属性列表的结构，即属性集(collection of properties)。
       * 
       * 实例的隐藏属性proto不可访问，通过实例的constructor属性连接到原型链上。
       * 
       * 理论上我们可以先构建一个没有任何成员的类属关系的继承系统，然后通过修改原型来获得一个
       * 完整的对象系统。
       * 
       * js只能依赖变量作用域来实现封装性，变量作用域只有表达式、函数、全局三种。
       * 
       * 天然多态性，js子类总是无法调用父类的同名方法。
       * 
       * “事件”的本质，在确定的时候发生的、可用用户代码响应的行为。
       * 
       * 构建原型继承关系的唯一方法是使用new语句来创建子类的原型。会使得JavaScript系统维持对象系统
       * 的原型链，这也是唯一一种影响内部原型链的形式(p197)
       * 
       * 类抄写成员访问效率更高但内存占用较大，而原型继承反之；
       * 类抄写不依赖内部原型链来维护继承关系，因此也不能通过instanceof来做这种检测，原型继承可以在
       * new运算时维护这种继承关系，也可以检测之；
       * 除此之外，原型继承的引用类型复制，用的是同一个引用，实例需要单独构造自身的引用类型属性。
       * 
       * 建议在大型系统上用类继承的思路，在小型结构或者体系的局部使用原型继承的思路。
       * 
       * 内置(Build-in)对象与原生(Native)对象，前者是后者子集并在引擎初始化阶段被创建好。
       * 12标准内置对象: Null Number Boolean String Object Function Array RegExp Error
       * Date Math JSON Global Arguments。
       * 宿主对象，宿主框架注册进JavaScript中的对象，Window、Navigator、Image等。
       * 引擎扩展对象，不同引擎不太一样。
       * 
       * 内置对象/类的一些特殊效果不能被对象系统继承。
       * 
       * 一个属性的性质(attributes)并不用于描述该属性的类型和作用，而是主要用于描述一个属性与这个
       * 集合的种种关系，即属性描述符。
       * 属性三类：一般数据属性、存取属性(get/set)、内部属性(不可见)。
       * 
       * 原型继承本质上是复制原型：以原型为模板复制出一个新的对象，构造器函数本身是无意义的，只是起到
       * 对实例修饰的作用。
       * Object.create()，将构造器函数从对象创建过程中赶了出去，对象变成了“原型继承+属性定义”，不再需要
       * 构造器了，newObj = Object.create(prototypeObj, PropertyDescriptors)，此时原型的
       * constructor指向内建的Object()构造器。
       * 
       * 本质上，delete运算时删除对象属性的属性描述符，而非某个属性。
       * 
       * for in 列举对象的全部可见属性，包括继承来的；
       * Object.keys() 只列举自己的可见属性；
       * Object.getOwnPropertyNames() 列举自有的全部可见和不可见属性；
       * 
       * 子类重写原型上的属性描述符时，会在子类上添加一个新的属性描述符的属性。
       * 
       * 函数式语言被认为是基于数学函数的一种语言，描述：
       * 数学函数是集合A(称为定义域)的成员到集合B(称为值域)的成员的映射；
       * 函数式程序设计师通过数学函数的定义、应用的说明和求值完成运算过程的。
       * 函数只有运算元的含义而没有地址的含义，函数参数与普通参数并没有什么不同。
       * 
       * JavaScript函数式语言特性：函数式运算元、在函数内保存数据、函数内的运算对函数外
       * 无副作用(需要开发人员保证：不修改全局变量、不在函数内修改对象或数组成员，这些成员应该由
       * 对象方法而非对象系统外的函数修改)。
       * 
       * 连续赋值 var a=b=c=100; 结果都是100，后面表达式的值赋给前面的变量；
       * 三元表达式的连用；
       * 
       * 通过表达式消灭分支语句；
       * 通过函数递归消灭循环语句(使用尾递归)；
       * 
       * 函数式语言中函数概念应该是lambda，基于lambda运算而产生的运算泛型
       * JavaScript函数式语言特性集：
       * 在函数外消除语句，只使用表达式和函数，通过连续求值来组织代码；
       * 在值概念上，函数可作为运算元参与表达式运算；
       * 在逻辑概念上，函数等义于表达式运算符，其参数是运算元，返回运算结果；
       * 函数严格强调无副作用。
       * 
       * JavaScript的函数：
       * 可变参数与值参数传递，传入参数的引用，函数对他的任何修改都不会传出，不能通过修改参数
       * 来影响到函数外部的变量，但可以通过成员赋值或方法调用来影响对象的成员；
       * 
       * 非惰性求值，函数参数为表达式时，无论函数里有没有用到，都会执行；
       * 
       * 函数是“一等公民”(first-class data types)，一般理解为语言中用来组织、声明其他复合
       * 类型的基本元素，它在语言/语法解释器级别存在，无须用户代码重述，
       * JavaScript中的第一型：undefined、string、boolean、number、object、function；
       * 
       * 函数是一个值，可以被存储在变量中，可以直接参与表达式运算，可以作为其他函数的参数或结果传出；
       * 
       * 可遍历的调用栈
       * 函数自身: arguments.callee
       * 调用者: arguments.caller
       * 
       * ***
       * 闭包的特点：闭包作为与函数成对的数据，在函数执行过程中处于可访问状态；
       * 闭包在函数运行结束后，保持运行过程中最终数据状态。
       * 
       * 在运行的过程中，子函数（闭包）可以访问upvalue；
       * 同一个函数的所有子函数（闭包）访问同一份upvalue。
       * 
       * 一个函数代码可以有多份函数实例，一个函数实例可以有多个函数引用。
       * 闭包是对应于运行期的函数实例的，而不是对应函数（代码块）的。所有要搞清楚哪些情况下产生
       * 实例就能确定运行的闭包环境。
       * 
       * 调用对象就是当前正在调用函数的ScriptObject结构，全局对象就是系统全局环境下的一个
       * ScriptObject结构。
       * 
       * 在函数开始执行时，varDecls中所有值将被置为undefined，varDecls总在语法分析阶段
       * 就创建好了并总在执行前被初始化；
       * 函数执行结束并退出时，varDecls不被重置，所有能在函数内保存函数；
       * 函数内数据持续的生命周期取决于该函数实例是否存在活动引用，没有则调用对象(ScriptObject)
       * 被销毁；
       * 
       * “全局调用对象”维护规则具有特殊性：该函数不会被再次进入，因此不会被重新初始化；该函数仅有
       * 一个被系统持有的实例，因此其自身和内部数据总不会被销毁。
       * 
       * 当传入参数是一个引用且被闭包内的某个变量赋值、传递或收集，会算入引用计数。
       * 
       * 当一个函数实例的所有引言者都被销毁时，函数实例及其闭包、调用对象也被销毁。
       * 
       * 函数实例与闭包的生存周期是分别管理的；
       * 函数被调用时，即"()"被运算时总是初始化一个闭包，而上次调用中的闭包是否被销毁，取决于
       * 该闭包中是否有被（其他闭包）引用的变量/数据。
       * 
       * 函数变量没有闭包的情况：
       * 闭包创建自函数执行开始之始；
       * 在执行中闭包没有被其他对象引用；
       * 在函数执行结束时闭包被销毁了。
       * 这时函数实例及其引用都还存在，只是没有对应的闭包了。
       * 
       * 函数闭包内标识符优先规则：内部函数声明优先于参数名；内部函数或参数名有arguments名称
       * 的标识符时，将导致当前函数的arguments对象不被创建；函数内的局部变量声明时，如果指定
       * 名称的标识符已经被绑定（例如内部函数名或参数名），则忽略改变量的标识符声明。
       * 
       * 函数名是该闭包中最先被初始化的标识符。
       * 
       * Function()构造器在任意位置创建的实例都处于全局闭包中。
       * 
       * 由于每一个函数实例都有一份ScriptObject的副本，因此不同的闭包访问到的私有变量不一致。
       * 
       * ***
       * JavaScript动态语言特性
       * 动态类型、动态重写和动态存取的数据结构、动态的变量/语法作用域。
       * 解释而非编译，没有真正的编译器；
       * 可以重写标识符，本质上是标识符动态类型绑定和动态数据绑定；
       * 动态类型系统，变量在声明时是无类型的，直到被赋个有类型含义的值；
       * 动态执行；
       * 丰富的数据外部表示；
       * 
       * JavaScript的代码总是运行在一个闭包环境中，这样它才会有一个ScriptObject用以访问当前
       * 闭包中的变量表(varDecls)与内嵌数表(funDecls)，并能通过闭包的parent属性访问到外层闭包。
       * 
       * eval()的闭包环境，不同引擎表现不一致。
       * 
       * ***
       * 动态方法调用
       * JavaScript中没有严格的方法，对象方法只是用成员存取运算符.、[]找到对象成员，然后该成员
       * 作为函数执行而已。调用对象方法，与作为普通函数调用改成有并没有本质的不同，只是传入的this
       * 引用不同。所有将普通函数作为一个对象的方法调用，或者将A对象的方法作为B对象的方法调用，只
       * 要改变this引用。
       * 
       * apply()与call()约定的参数形式是数组或arguments。
       * 
       * 可以通过arguments.callee.caller.arguments[0] = 1; 可以通过这种方式在被调用函数中
       * 修改调用函数的参数，很危险。
       * 
       * 函数总是运行在自己所在的闭包环境中，这与是否通过call()或apply()调用无关。
       * 
       * bind()将函数绑定到一个对象上，并返回绑定后的函数。绑定后的函数总是作为该对象的一个方法
       * 调用，无论是否为其他对象的属性或者作为函数调用。绑定后的函数也可作为构造器使用，构造出的
       * 对象既是绑定后的函数实例也是绑定前的函数实例。
       * bind()返回的函数不存在prototype属性。
       * 
       * ***
       * 重写
       * 重写构造器原型会导致原型继承关系丢失。
       * 构造器本身的重写(给构造器赋值一个新函数)也好导致继承关系丢失。
       * 
       * 构造器的原型创建自系统内部的对象系统，而不是可被外部覆盖的标识符Object，因此原型总能
       * 被创建。
       * 
       * 直接量声明总是调用对象内部系统来构造对象，处理undefined之外所有的直接量都有对应的构
       * 造器。构造器被重写后，不影响直接量声明，直接量只与重写钱的构造器相关。
       * 
       * 在SpiderMonkey JavaScript中，对象类型的直接量声明与它的构造类直接绑定，直接量声明
       * 过程本质上就是对应的构造类创建实例的过程。
       * 
       * 成员重写
       * 有些成员是只读的，不能重写。
       * location=''，重写location会修改内部href值，切换网址。
       * 
       * ***
       * 包装类
       * JavaScript有两套类型系统，一是元类型系统(meta types)，可由typeof检测，包括undefined、number、
       * boolean、string、function、object。
       * 二是对象类型系统，对象类型系统是元类型object的一个分支。
       * 为了除了undefined之外，一切都是对象，可以用包装类将元类型变成对象类型来处理(Boolean、
       * Number、String)。
       * 
       * 这样，对象类型系统中的每一个实例以及元类型数据通过包装类装换而来的数据，都将是对象。
       * 元数据通过包装类包装后得到的对象，与原来的元数据不再是同一数据，只是等值。
       * 
       * 包装类：Number()、Boolean()、String()
       * 与类型强制转换不同，强制转换是在同一数据(相同内存地址的不同引用)上进行的，但上述会产生
       * 一个新的数据。
       * 与Object()不同，object不是元类型中的值类型数据，Object()传入参数也只能是boolean、number、
       * string三种值类型数据之一，表明将这些值类型数据通过显式包装转换为同等的对象数据；
       * Object()可以不用new，包装类必须用new；
       * 
       * 元数据到对象的隐式包装，总是发生在成员存取运算符中(for in和with语句也会导致包装类)。
       * 
       * 对值类型的方法调用，实际上是临时产生的包装后的对象，调用结束后就被销毁。
       * 
       * ***
       * 直接量
       * Object、Array、RegExp三种对象存在直接量声明语法
       * 加上function，这些引用类型的直接量总是由他对应的构造器产生的一个对象实例，在声明直接量时，
       * 相对应的构造器会被调用并创建一个对象实例。
       * 
       * 函数特例
       * typeof对函数直接量与包装后的对象检测都返回'function'，这表现了JavaScript作为函数式语言的
       * 特性：函数是第一类的；
       * instanceof检测，都是Function的一个实例，这表现了JavaScript作为面向对象语言的重要特性：
       * 函数是对象。
       * 
       * ***
       * 对象与数组的动态特性
       * 
       * JavaScript的数组下标必须是值类型，用引用类型(object/function)或undefined类型，会被
       * 转换为字符串。
       * 值类型数据包括number、boolean、string，只有boolean是序数的(number在JavaScript中
       * 是浮点数)。所有JavaScript数组为关联数组。
       * 
       * 关联数组是对象系统的基础，早在Array类型之前，系统已经为Object类型实现好了关联数组，
       * JavaScript对象的“表特征”非常明显：可以用[]存取成员。
       * 
       * JavaScript对象(的原型)所持有的属性表，就是一个关联数组的内存表达
       * 属性存取，其实就是查表；
       * 对象实例，其实就是一个可以动态添加元素的关联数组；
       * 原型继承，其实就是在继承链的关联数组中查找元素。
       * 
       * JavaScript的索引数组，只是用数字的形式(内部仍是字符串的形式)来存取一个关联数组。
       * 关联数组是无序的。
       * 
       * ***
       * 类型转换
       * 由于变量类型在语法解释期间无法确定，只能在代码执行过程中才能获知，所有JavaScript只能
       * 采用“运算过程中执行某种类型转换规则”来解决不同类型间的运算问题。比如数字+字符串是把数字
       * 转换为字符串后拼接而不是把字符串转换为数字再加。
       * 
       * 有且只有NaN是自身不等值。
       * 
       * 某些宿主环境下的特殊类型系统，如JScript允许扩展类型系统(typeof的值不是元类型的之一)。
       * 
       * 元类型只有两类：值类型和引用类型。只有函数和对象是引用类型，JavaScript对象系统衍生自
       * 元类型object，函数式语言特性则基于元类型function。
       * 运算的实质是值运算，引用类型自身不参与值运算，作用为：标识一组值数据；提供一组存取数据
       * 的规则；在函数中传递与存储引用。
       * 所有类型转换指的是：值类型直接的转换(不包括undefined，因为undefined表示不存在的值，任何
       * 存在的值不可能变成不存在的)；将引用类型转换为值类型(以参与运算)。
       * 
       * 通过函数或方法调用，明确地将类型转换为另一类型称为显式转换，相对应的为隐式转换，一般发生在
       * 表达式运算和某些语句对数据的理解上。
       * 
       * JavaScript运算过程中的隐式类型转换，既受基于运算符的“类型推定”影响，又受基于运算元的
       * “运算符推定”影响。
       * 
       * 一些语句在语法分析时也会做一些强制转换的操作，if语句、while()等会把表达式运算结果
       * 转换为布尔值。
       * switch()会先视图对表达式求值再与case的值比较，类似'==='运算，会优先进行类型检测而
       * 不会发生类型转换过程。
       * 
       * **
       * 值类型之间的转换
       * 
       * undefined的转换：
       * 任何值都不能转换为undefined，反过来undefined能转换为字符串'undefined'与false，
       * 与数值运算时会产生NaN。
       * 
       * number的转换：
       * 任何值都能转换为number类型，如果得不到一个有效的值，就会是NaN，NaN可以参与数值运算，
       * 这样处理的目的是让表达式可以尽量求值。
       * 转为布尔类型，非零为true，零和NaN为false。
       * 
       * boolean的转换：
       * 转为数字 true和false对应1和0，
       * 转为字符串 true和false对应'true'和'false'
       * 
       * string的转换：
       * 如果一个字符串由数值和不多于一个的小数点构成，那么总能被转换为数值，
       * 只有空字符串能被转换为boolean值false，其他都是true。
       * 
       * 值类型数据的显式转换
       * Global.parseInt()、Global.parseFloat()
       * 
       * 如果一个引用类型数据要进行值运算，那么引擎将先调用其(或经过包装后的对象)的valueOf方法
       * 求值，然后用该值参与值运算。
       * 
       * 在布尔运算中，无值的(0、undefined、null和空字符)为false，其他有值的数据直接被作为true
       * 无需类型转换。
       * 
       * 数据是值类型，则直接参与值运算；
       * 如果valueOf()返回一个值类型数据，则以该数据值参与值运算；
       * 使用toString()返回的字符串参与运算。
       * 
       * JavaScript中的任意一种数据类型，都可以转换为字符串，因为JavaScript约定一切都是对象(undefined除外)，
       * 所有必然存在toString()方法以取得当前对象的字符串值。
       * 
       * ***
       * 常用技巧
       * 消除代码的全局变量名占用：
       * 使用立即执行的匿名函数。
       * 
       * 一次性的构造器
       * 
       * 用一个对象来充当函数调用界面(是在内部调用还是在外部调用)上的或针对特殊成员(是不是自身的成员)
       * 的识别器。
       * 
       * 使用直接量或包装类快速调用对象方法：
       * [].push.apply(obj,[1,2,3])
       * 
       * 日期对象的valueOf返回的数值，所有可以直接加减乘除运算。
       * 
       * 通过对象的值含义(valueOf)构造具有相对复杂逻辑的对象或对其实例做值运算。
       * 
       * 构造一个替换过程相关的对象，用于控制字符串替换过程。
       * 
       * 将函数封装为方法，使之在调用时使用特定的this引用的简单方法。
       * 
       * 使用对象闭包重置重写：
       * 用闭包保存原来的数据，用方法恢复。
       * 
       * 通过数组方法，动态地创建函数调用参数。
       * 
       * 使用更复杂的表达式消减if语句
       * 
       * 钩子函数，指模拟原始函数的功能与接口，在原始函数执行前、执行后增加一些特殊功能或检测代码
       * 的技术。在更接近系统层次上的技术中，被称为Hook，在更面向应用的高级开发中，一般使用子类
       * 继承或切面技术来实现相同的功能。
       * 
       * 在函数内安全地使用字符串参数：
       * var str = str + ''; 注意声明一个新变量，避免直接重写原变量在某些情况下会有副作用。
       * 
       * 
       * 
       * 
       * 
       */



      // function MyObject(){}
      // function MyObjectEx(){
      //   /*this.constructor = MyObjectEx; /* 构造出的实例construtor属性指向始终为MyObjectEx，等于实例自己维护一个constructor
      //                                     属性，与原型上的constructor属性不冲突 */
      // }
      // let proto = new MyObject();
      // MyObjectEx.prototype = proto;
      // // MyObjectEx.prototype.constructor = MyObjectEx; //重置原型以后再修改构造器值

      // var obj1 = new MyObject();
      // var obj2 = new MyObjectEx();
      // console.log(
      //   proto.constructor === MyObject,
      //   MyObject.prototype.constructor === MyObject,
      //   MyObjectEx.prototype.constructor === MyObject,
      //   obj1.constructor === obj2.constructor === MyObject,
      // );
      // console.log(obj2)

      /**
       * Object.create()大致实现(省略参数检测)，引擎内部直接修改obj对象的内部原型值，
       * 代码无法重现，因为Object.prototype是readOnly
      */
      // function aCreator(proto, props){
      //   var obj, __proto__ = Object.prototype;
      //   try {
      //     Object.prototype = proto;
      //     obj = new Object();
      //   }
      //   finally{
      //     Object.prototype = __proto__;
      //   }
      //   Object.defineProperties(obj, props);
      //   return obj;
      // }

      /**
       * 闭包
       */
      // TheContext = {            //执行上下文
      //   type: 'FUNCTION',
      //   name: 'myFunc',
      //   params: [],             //参数
      //   body: ScriptObject      //调用对象
      // }
      // ScriptObject = {
      //   type: 'SCRIPT',
      //   varDecls: [],           //内部变量表
      //   funDecls: [],           //内嵌函数表
      //   source: '',             //其余代码
      // }

      // var obj = new Object();
      // var events = {m1: 'clicked', m2: 'changed'};
      // for (var e in events){
      //   // let func = function(){
      //   //   console.log(func.value);
      //   // }
      //   // func.value = e;
      //   // obj[e] = func;
      //   // (obj[e] = function func(){
      //   //   console.log(func.value)
      //   // }).value = e;

      //   // obj[e] = (function(value){
      //   //   return function(){
      //   //     console.log(value)
      //   //   }
      //   // })(e);

      //   obj[e] = new Function('console.log("'+events[e]+'")');
      // }
      // obj.m1();
      // obj.m2();

      // (function Object(){}).prototype.value = 100;
      /*在执行期，将直接量作为表达式时就没有了语法期命名的含义，等效于=>(function (){})，相当于修改了
      一个匿名函数的原型，这个函数在表达式执行后没有任何引用，被释放了，所有不会对外面有影响
      */
      // var obj = new Object();
      // console.log(obj.value);

      // var MyObject2 = (function MyObject(){});
      // console.log(MyObject2 === MyObject);

      // Number.prototype.showType = function(){
      //   console.log(this, typeof this);
      // }
      // var num = 100;
      // console.log(typeof num);
      // num.showType();



 
      

























    }

    render(){
        return (
        <div>
            <br/>
            <h2>Practice</h2>
        </div>
        )
    }
}